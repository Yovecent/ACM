##  ğŸ§†ABC Conjecture

   yzggç§’äº†çš„é¢˜ï¼Œæˆ‘å¥½æ€»ç»“æ€»ç»“ï¼Œå‘œå‘œå‘œã€‚ã€‚ã€‚
   
   
   é¢˜é¢æ˜¯è¯´çš„ï¼Œå¯¹äºç»™å®šçš„ $c$ ,è®©æˆ‘ä»¬æ‰¾å‡º $a + b = c$ ä½¿å¾— $rad(abc) < c$
   
   æˆ‘ä»¬è‚¯å®šæ˜¯å°½å¯èƒ½åœ°æ„é€ å‡º $a,b$ ä¸ $c$ æœ‰æ›´å¤šç›¸åŒçš„è´¨å› æ•°ã€‚
   
   ä¸€å¼€å§‹æƒ³å‡äº†ï¼Œä¸€ç›´åœ¨æ¨å¦‚æœè¯´ $c$ å·²ç»åˆ¤åˆ«å‡ºæ˜¯å¥‡æ•°è¿˜æ˜¯å¶æ•°åœ°æ—¶å€™ï¼Œæˆ‘ä»¬æ¥åˆ¤æ–­å‡ºæ¥æ˜¯å¦ä¸€å®šæœ‰è§£ã€‚
   ä½†æ˜¯æ¨äº†å¥½ä¹…å‘ç°éƒ½æ²¡åŠæ³•å®ç°ã€‚
   
   ç„¶åçªç„¶å‘ç°å¥½åƒ $c$ æ˜¯ç”±è´¨å› æ•°ä¹˜ç§¯å¾—åˆ°çš„è¯æ˜¯ä¸€å®šæ˜¯æ— è§£çš„ï¼Œè¿™æ—¶å€™æ‰è¿·ç³Šè¿‡æ¥å¥½åƒæ˜¯è¿™ä¸ªç†ï¼Œç„¶åæ‰“äº†è¡¨
   å‘ç°åªæœ‰è¿™ç§æƒ…å†µä¸‹æ‰ä¼šå‡ºç°æ— è§£ã€‚
   
   è¿™é‡Œæˆ‘ä»¬æ¥è¯æ˜ä¸€ä¸‹ã€‚
   å¯¹äºä¸€ä¸ªæ•° $n$ æˆ‘ä»¬å°†å…¶è¡¨ç¤ºä¸ºç´ æ•°ä¹˜ç§¯çš„å½¢å¼ :   
    =  ${p1}^{n} * p2 * p3....$  
    =  $p1^{n - 1} * ((p1 - 1) + 1) * p2 * p3....$  
    =  $((p1 - 1) + 1) * {p1}^{n - 1} * p2 * p3....$  
   æ­¤æ—¶æˆ‘ä»¬å°†é‚£ä¸ªåŠ å·æ‹†å¼€å°±æ˜¯ $a$ å’Œ $b$äº†ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆå¿…é¡»æœ‰ä¸€ä¸ªè´¨å› æ•°å¹‚å¤§äº1çš„åŸå›   
   
   
   
   
   å¥½äº†ç°åœ¨æˆ‘ä»¬çš„ä»»åŠ¡å˜æˆäº†æ€ä¹ˆå¿«é€Ÿåœ°åˆ¤æ–­å‡ºä¸€ä¸ªæ•°æ˜¯å¦æœ‰å¤§äº2åœ°æ¬¡å¹‚åœ°è´¨å› æ•°ã€‚
   
   å¯¹äºåˆ¤æ–­ä¸€ä¸ªæ•°çš„è´¨å› æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ $\sqrt{n}$çš„æ—¶é—´å¤æ‚åº¦ä¸‹åˆ¤æ–­å‡ºæ¥ï¼Œå› ä¸ºæˆ‘ä»¬çš„æ ·ä¾‹æ•°åªæœ‰
   10ä¸ªï¼Œæ‰€ä»¥æˆ‘ä»¬å¦‚æœåªå¤„ç†1åˆ° $1e12$ ä¹‹é—´çš„æ•°çš„è¯é‚£ä¸€å®šæ˜¯å¯ä»¥çš„ã€‚é‚£å¯¹äº $1e12$ åˆ° $1e18$ ä¹‹é—´çš„æ•°æ€ä¹ˆæ±‚å‘¢ï¼Ÿ
   
   
   å› ä¸ºæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¦‚æœå°†å¯¹äºå‰©ä¸‹çš„æ•°ï¼Œå…¶è´¨å› æ•°åªå¯èƒ½æ˜¯åœ¨ $1e6 ~ 1e9$ ä¹‹é—´ï¼Œé‚£ä¹ˆä»–çš„å¹‚æ¬¡ä¸ä¼šè¶…è¿‡äºŒï¼Œå¦‚æœæˆ‘ä»¬
   æŠŠ $1 ~ 1e6$ ä¹‹é—´çš„å› æ•°æ¶ˆå»ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„çš„å°±æ˜¯å¤„åœ¨$1e6 ~ 1e9$ ä¹‹é—´çš„æ­¤æ—¶æˆ‘ä»¬åªéœ€è¦åˆ¤æ–­ä»–æ˜¯ä¸æ˜¯ä¸€ä¸ªå¹³æ–¹æ•°
   å°±å¯ä»¥äº†ï¼Œå¦‚æœä¸æ˜¯é‚£è¯´æ˜å…¶å¹‚æ¬¡è¿˜æ˜¯ä¸€ä¸ªï¼Œå¤ªå·§ç§’äº†ï¼ï¼ï¼ï¼
   
```C++
#include <bits/stdc++.h>

using namespace std;
const int maxn = 1e6 + 1;
using i64 = long long;

vector<int> prime;
bool vis[maxn];

void Pre () {

	for (int i = 2; i < maxn; i++) {
		if (!vis[i]) {
			prime.push_back(i);
		} 
		for (int j = 0; j < prime.size() && prime[j] <= (maxn - 1) / i; j++) {
			vis[prime[j] * i] = true;
			if (i % prime[j] == 0) break;
		}
	}
}
int main () {
	Pre();

	int t;
	scanf("%d", &t);
	while (t--) {

		i64 n;
		scanf("%lld", &n);
		
		bool ok = false;
		for (auto x : prime) {
			if (x > n) break;
			if (n % x == 0) {

				int s = 0;
				while (n % x == 0) s++, n /= x;
				if (s >= 2) {
					ok = true;
					break;
				}
			}
		}

		if (ok) {
			printf("yes\n");
			continue;
		} else if (n <= 1e12) {
			printf("no\n");
			continue;
		}

		ok = true;
		i64 y = sqrt(n);
		if (y * y != n) {
			printf("no\n");
		} else {
			printf("yes\n");
		}
	}
	return 0;
}
```


##  L. Clock Master


   å› ä¸ºä¸ä¼šè®¡ç®—æ—¶é—´å¤æ‚åº¦è€Œè¿Ÿè¿Ÿä¸æ•¢å†™çš„ä¸€é“é¢˜ã€‚


   å› ä¸ºå–æ¨¡æ“ä½œæˆ‘ä»¬å¯ä»¥çŸ¥é“å¦‚æœt1å®šäº†çš„è¯é‚£å°±æ˜¯æ¯t1å¾ªç¯ä¸€ä¸‹ï¼Œè€Œå¯¹äºä¸åŒçš„tæˆ‘ä»¬å¯ä»¥çŸ¥é“å…¶å®å°±æ˜¯å…¶
   æœ€å°å…¬å€æ•°å°±æ˜¯æœ€ç»ˆçš„ä¸åŒæ–¹æ¡ˆæ•°ã€‚

   é‚£ä¹ˆæˆ‘ä»¬ç›®æ ‡å¾ˆæ˜ç¡®ï¼Œæ‰¾å‡ºæ‰€æœ‰åœ¨ $3e4$ ä»¥å†…çš„è´¨æ•°ï¼Œç„¶åè®©è¿™äº›è´¨æ•°ç›¸äº’é…ä»è€Œå‡‘å‡ºæœ€å¤§çš„æ–¹æ¡ˆã€‚
   å¯¹äºä¸€ä¸ªè´¨æ•°æˆ‘ä»¬åªä¼šå°†å…¶æ”¾åœ¨ä¸€ä¸ªté‡Œé¢ï¼Œè¿™æ ·æ‰ä¼šä¿è¯ä¸æµªè´¹ï¼Œä½†æ˜¯æˆ‘ä»¬æ€ä¹ˆçŸ¥é“æ¯ä¸€ä¸ªæ”¾å‡ ä¸ªå‘¢ï¼Ÿ
   æˆ‘ä»¬å¯ä»¥çŸ¥é“çš„æ˜¯æœ€å¤šæ”¾ $logn$ä¸ªï¼Œæˆ‘ä»¬å¦‚æœè¿›è¡Œdpçš„è¯ï¼Œä¸€å®šè¦å°†ä¸€ä¸ªè´¨æ•°çš„æƒ…å†µéƒ½æ›´æ–°å‡ºæ¥ï¼Œ
   å¹¶ä¸”åˆ©ç”¨çš„æ˜¯ä¸Šä¸€ä¸ªçš„æ•°æ®ï¼Œå› ä¸ºæˆ‘ä»¬æ›´æ–°å…¶ä»£ä»·ä¸º $p^k$ï¼Œ è€Œä¸æ˜¯ç®€å•çš„åŠ æ³•ï¼Œæ‰€ä»¥ä¸æ˜¯å®Œå…¨èƒŒåŒ…ï¼Œ
   åº”è¯¥æ˜¯åˆ†ç»„èƒŒåŒ…ã€‚

   ä½†æ˜¯å½“æ—¶å†™çš„æ—¶å€™è®¡ç®—äº†ä¸€ä¸‹å¯¹äºæ¯ä¸€ä¸ªè´¨æ•°å…ˆè¦æšä¸¾å‡ ä¸ªï¼Œç„¶åæ›´æ–°ï¼Œè¿™æ ·çš„è¯æ—¶é—´å¤æ‚åº¦å°±æ˜¯
   O(log(3e4) * log(3e4) * 3e4) é“Tã€‚


   ä½†äº‹å®æ˜¯æ—¶é—´å……è£•å¾—å¾ˆï¼Œå› ä¸ºæˆ‘ä»¬åœ¨è´¨æ•°å¤§å°è¶…è¿‡10ä¹‹åæšä¸¾çš„æ¬¡æ•°éƒ½ä¸ä¼šè¶…è¿‡4ä¹Ÿå°±æ˜¯è¯´å¯æšä¸¾çš„æ¬¡æ•°å…¶å®
   æ˜¯å¾ˆå°‘çš„ï¼ŒåŒæ—¶æˆ‘ä»¬å¦‚æœå€’ç€æ¥æ›´æ–°çš„è¯ï¼Œè¿™æ ·æˆ‘ä»¬çš„è´¨æ•°è¶Šå¤§æ›´æ–°çš„æ¬¡æ•°ä¹Ÿå°±è¶Šå°ï¼Œç»¼åˆæ¥çœ‹æ—¶é—´ç¡®å®æ˜¯å¯ä»¥çš„ã€‚

   è¿™é‡Œè¿˜ç”¨äº†æ»šåŠ¨æ•°ç»„çœäº†ä¸€ç»´ã€‚
   åŒæ—¶æˆ‘ä»¬å…ˆæšä¸¾ä½¿ç”¨çš„æ¬¡æ•°é‡Œé¢æšä¸¾ æ¬¡æ•°æ›´åŠ é«˜æ•ˆï¼ï¼ï¼
     
     
     
```C++
#include <bits/stdc++.h>

using namespace std;
const int maxn = 3e4 + 10, N = 3e3 + 250;
using i64 = long long;

vector<int> prime;
bool vis[maxn];

void Pre () {

	for (int i = 2; i <= maxn - 10; i++) {
		if (!vis[i]) {
			prime.push_back(i);
		}
		for (int j = 0 ; j < prime.size() && prime[j] <= (maxn - 10) / i; j++) {
			vis[i * prime[j]] = true;
			if (i % prime[j] == 0) break;
		}
	}
}

int v[N], cnt[N];
double w[N], dp[maxn];

int main () {

	Pre();
	int n = prime.size();

	for (int i = 1; i <= n; i++) {
		v[i] = prime[i - 1];
		w[i] = log(prime[i - 1]);
	}

	for (int i = 1; i <= n; i++) {

		for (int j = maxn - v[i]; j >= 0; j--) {
			double W = 0;
			for (int V = v[i]; j + V < maxn; V *= v[i]) { //æœ€åæšä¸¾ç»„å†…çš„æƒ…å†µã€‚
				W += w[i];
				dp[j + V] = max(dp[j + V], dp[j] + W);
			}
		}
	}

	int t;
	scanf("%d", &t);

	while (t--) {
		int m;
		scanf("%d", &m);
		printf("%.7f\n", dp[m]);
	}

	return 0;
}
```

##  C. Rencontre


  å“ï¼Œå¤ªèœäº†ï¼Œæ¨äº†ä¸€ç‚¹ä¸œè¥¿å°±å¼€å§‹å†™ï¼Œå†™äº†åŠå¹´éƒ½æ²¡å†™å‡ºæ¥ã€‚
  
  é¦–å…ˆæˆ‘ä»¬çŸ¥é“çš„æ˜¯ï¼Œæˆ‘ä»¬æ¯æ‰¾å‡ºä¸‰ä¸ªç‚¹æˆ‘ä»¬å°±å¯ä»¥ç¡®å®šä»–çš„æœ€å°è·ç¦»ä¸€å®šå°±æ˜¯å…¶ä¸­ä¸€ä¸ªç‚¹ï¼ˆä¸­ç‚¹ï¼‰ï¼Œä½†æ˜¯æˆ‘ä»¬
  å¹¶ä¸çŸ¥é“è¿™ä¸ªç‚¹æ˜¯å“ªä¸ªï¼Œä¸€å¼€å§‹æˆ‘ä»¥ä¸ºå°±æ˜¯æšä¸¾æ¯ä¸€ç‚¹æ˜¯ä¸­ç‚¹ç„¶åå»ç®—ä¸€ä¸‹å…¶å­æ ‘ä»¥åŠå‘ä¸Šçš„ç‚¹æ„æˆçš„æ–¹æ¡ˆï¼Œä½†æ˜¯
  ç®—äº†ä¸€å¹´éƒ½æ²¡æœ‰ç®—å‡ºæ¥ã€‚
  
  
  ç°åœ¨æ¥ä¸€æ³¢å¾ˆä¸“ä¸šçš„æœŸæœ›é€‰æ‰‹åº”è¯¥æ¨å‡ºçš„å¼å­ã€‚
  
  é¦–å…ˆæˆ‘ä»¬éœ€è¦çŸ¥é“çš„æ˜¯ï¼Œå…¶æœ€çŸ­è·ç¦»ä¹‹å’Œå°±æ˜¯æ¯ä¸¤ä¸ªç‚¹ä¹‹é—´çš„è·ç¦»ç›¸åŠ é™¤ä»¥äºŒï¼Œæ˜¯ä¸æ˜¯å¾ˆç¥å¥‡ã€‚
    
  $$
  E(x) = E(u1, u2, u3)
       = {E((u1, u2) + (u2, u3) + (u1, u3))} / 2  
       = {E(u1, u2) + E(u2, u3) + E(u1, u3)} / 2  
  $$
    
  æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦è®¡ç®—å‡ºæ¥æ¯ä¸¤å—ä¹‹é—´çš„è·ç¦»çš„æœŸæœ›å°±å¯ä»¥äº†ã€‚
  
  æ€ä¹ˆæ±‚å‘¢ï¼Œæˆ‘ä»¬åªéœ€è¦æšä¸¾æ¯ä¸€æ¡è¾¹ï¼Œç„¶åç®—ä¸¤è¾¹çš„ä¸è¡Œçš„å—çš„æ•°é‡çš„ä¹˜ç§¯ï¼Œç„¶åè®©
  $E(u1, u2) = sum(u1, u2) / cnt1 / cnt2$ å°±å¯ä»¥äº†
  
  å‘œå‘œå‘œï¼Œå·¨å·¨ä»¬éƒ½å¤ªå¼ºäº†ï¼ŒæœŸæœ›é€‰æ‰‹å¤ªå¼ºã€‚
  
```C++
#include <bits/stdc++.h>

using namespace std;
using i64 = long long;
const int maxn = 2e5 + 10;

int cnt[3], sons[maxn][3], vis[maxn][3];
vector<pair<int, int> > adj[maxn];
i64 sum[3][3];

void dfs (int u, int pre) {

	for (auto x : adj[u]) {
		int v = x.first;
		if (v == pre) continue;

		dfs (v, u);
		for (int i = 0; i < 3; i++) {
			sons[u][i] += sons[v][i];
		}
	}

	for (int i = 0; i < 3; i++) {
		sons[u][i] += vis[u][i];
	}
}

void dfs2 (int u, int pre) {

	for (auto x : adj[u]) {
		int v = x.first, w = x.second;
		if (v == pre) continue;
		for (int i = 0; i < 3; i++) {
			
			for (int j = 0; j < 3; j++) {
				if (i == j) continue;

				sum[i][j] += 1ll * w * sons[v][i] * (cnt[j] - sons[v][j]);
			}
		}

		dfs2 (v, u);
	}
}

int main () {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif

	int n;
	scanf("%d", &n);
	for (int i = 1; i < n; i++) {
		int u, v, w;
		scanf("%d %d %d",&u, &v, &w);
		adj[u].push_back({v, w});
		adj[v].push_back({u, w});
	}

	for (int i = 0; i < 3; i++) {
		scanf("%d", &cnt[i]);
		for (int j = 0; j < cnt[i]; j++) {
			int x;
			scanf("%d", &x);
			vis[x][i] = true;
		}
	}

	dfs (1, 0);
	dfs2(1, 0);

	double ans = 0;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			if (i == j) continue;

			ans += 1.0 * sum[i][j] / (1ll * cnt[i] * cnt[j]);
		}
	}
	printf("%.7f", 1.0 * ans / 2);

	return 0;
}
```


##  Caesar Cipher

   æˆ‘å®£å¸ƒå“ˆå¸Œé€‰æ‰‹åœ¨æ­¤æ‰³å›ä¸€åŸã€‚
   å‘œå‘œï¼Œå¦‚æœå“ˆå¸ŒGäº†ï¼Œæˆ‘ä¼šå¾ˆä¼¤å¿ƒçš„ã€‚
   
   å› ä¸ºå¯¹äºæ²¡æœ‰ä¿®æ”¹çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ¥æ±‚å‡ºä¸¤ç«¯ç›¸åŒçš„è¯å°±åªæœ‰å“ˆå¸Œå’ŒKMPäº†ï¼Œæ‰€ä»¥æƒ³çš„å°±æ˜¯è‚¯å®šæ˜¯å“ˆå¸Œæ²¡è·‘äº†ã€‚
   
   ååˆ†å…³é”®çš„ä¸€ç‚¹æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å–æ¨¡åˆ°å¤´çš„æ•°é‡ä¸ä¼šå¾ˆå¤šï¼Œå› ä¸ºæ¯è½®ä¸€æ¬¡éœ€è¦åŠ 65536ï¼Œ è€Œæˆ‘ä»¬çš„æ€»æ“ä½œæ¬¡æ•°
   ä¹Ÿå°± $5e5$ æ‰€ä»¥æˆ‘ä»¬å°±å¯ä»¥æ”¾å¿ƒå¤§èƒ†çš„å»è¿›è¡ŒåŠ ä¸€æ“ä½œäº†ã€‚
   ç„¶ååœ¨æ¯ä¸€æ¬¡æ“ä½œå®Œä¹‹åéƒ½è¦è¿›è¡Œæ£€éªŒæ˜¯å¦æœ‰åˆ°å¤´çš„ï¼Œç„¶ååœ¨é‡æ–°æ›´æ–°ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚
   æ‰€ä»¥æ—¶é—´å°±æ˜¯ O(åŒºé—´æ“ä½œ + å•ç‚¹æ“ä½œ)  è€Œå•ç‚¹æ“ä½œçš„æ—¶é—´æˆ‘ä»¬çŸ¥é“ä¸ä¼šå¾ˆå¤§ï¼Œæ‰€ä»¥å°±å¯ä»¥ç›´æ¥å†™äº†ã€‚
   
   ä½†æ˜¯å› ä¸ºæˆ‘å¤ªå‚»åŠäº†ï¼Œæ‰€ä»¥å¤„ç†çš„å¤ªéº»çƒ¦ï¼Œåœ¨é‡åˆ°ä¸€ä¸ªå®Œæ•´åŒºé—´ä¹‹ååœ¨å…ˆæ›´æ–°ä¸º0åœ¨å¯¹é—´éš” è¿›è¡Œç›´æ¥åŠ ä¸€æ“ä½œï¼Œ
   å…¶å®æˆ‘ä»¬å¯ä»¥ç›´æ¥åŠ ä¸€æ“ä½œï¼Œç„¶åå†å°†æ‰€ä»¥åˆ°å¤´çš„ç‚¹æ‰¾å‡ºæ¥å°±å¯ä»¥äº†ï¼Œå‘œå‘œå‘œå†™äº†ä¸€å¤©ï¼Œçœ‹åˆ°é»„è€å¸ˆçš„å†™æ³•äºº
   ç›´æ¥éº»äº†ï¼Œæ„Ÿè§‰è‡ªå·±æ˜¯ä¸ªæ²™é›•ã€‚
   
   
```C++
#include <bits/stdc++.h>

using namespace std;
using i64 = long long;
const int maxn = 5e5 + 10, clue = 65536;
const i64 Hash = 20023, mod = 3000000019;

i64 sum[maxn], P[maxn], a[maxn];
struct SegmentTree {

	int Max[maxn << 2], lazy[maxn << 2];
	i64 info[maxn << 2];
	void pushdown (int p, int l, int mid, int r) {
		if (lazy[p]) {
			lazy[p << 1] += lazy[p];
			lazy[p << 1 | 1] += lazy[p];
			info[p << 1] =  (info[p << 1] + sum[mid - l + 1] * lazy[p] % mod) % mod;
			info[p << 1 | 1] = (info[p << 1 | 1] + sum[r - mid] * lazy[p] % mod) % mod;
			Max[p << 1] += lazy[p], Max[p << 1 | 1] += lazy[p];
			lazy[p] = 0;
		}
	}
	void pushup (int p, int l, int mid, int r) {
		Max[p] = max(Max[p << 1], Max[p << 1 | 1]);
		info[p] = (info[p << 1] * P[r - mid] % mod + info[p << 1 | 1]) % mod;
	}
	void build (int p, int l, int r) {
		if (l == r) {
			Max[p] = a[l];
			info[p] = a[l];
			return;
		}
		int mid = l + r >> 1;
		build(p << 1, l, mid);
		build(p << 1 | 1, mid + 1, r);
		pushup(p, l, mid, r);
	}
	void update (int p, int l, int r, int L, int R) { //åŒºé—´åŠ ä¸€æ“ä½œ
		if (l >= L && r <= R) {
			Max[p] += 1;
			lazy[p] += 1;
			info[p] = (info[p] + sum[r - l + 1]) % mod;
			return;
 		}
		int mid = l + r >> 1;
		pushdown(p, l, mid, r);

		if (L <= mid) update(p << 1, l, mid, L, R);
		if (R > mid)  update(p << 1 | 1, mid + 1, r, L, R);
		pushup(p, l, mid, r);
	}
	void search(int p, int l, int r) { //æ‰¾æ»¡çš„ç‚¹
		if (Max[p] < clue) return;
		if (l == r) {
			info[p] = 0;
			Max[p] = 0;
			return;
		}
		int mid = l + r >> 1;
		pushdown(p, l, mid, r);
		search(p << 1, l, mid);
		search(p << 1 | 1, mid + 1, r);
		pushup(p, l, mid, r);
	}
	i64 query (int p, int l, int r, int L, int R) {

		if (l >= L && r <= R) {
			return info[p] * P[R - r] % mod;
		}
		int mid = l + r >> 1;
		pushdown(p, l, mid, r);

		i64 resl = 0, resr = 0;
		if (L <= mid) resl = query(p << 1, l, mid, L, R);
		if (R > mid)  resr = query(p << 1 | 1, mid + 1, r, L, R);
		return (resl + resr) % mod;
	}
}tree;

int main () {
#ifndef ONLINE_JUDGE
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif

	int n, q;
	scanf("%d %d",&n, &q);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

	sum[1] = 1;
	for (int i = 2; i <= n; i++) sum[i] = (sum[i - 1]* Hash % mod + 1) % mod ;
	P[0] = 1;
	for (int i = 1; i <= n; i++) P[i] = P[i - 1] * Hash % mod;
	tree.build(1, 1, n);


	while (q--) {
		int opt;
		scanf("%d", &opt);
		if (opt == 1) {
			int l, r;
			scanf("%d %d",&l, &r);
			tree.update(1, 1, n, l, r);

		} else {
			int l, r, len;
			scanf("%d %d %d",&l, &r, &len);
			if (tree.query(1, 1, n, l, l + len - 1) == tree.query(1, 1, n, r, r + len - 1)) {
				printf("yes\n");
			} else {
				printf("no\n");
			}
		}
		tree.search(1, 1, n);
	}
	return 0;
}
```
```diff
!    ğŸ¿2022-10-21
```
